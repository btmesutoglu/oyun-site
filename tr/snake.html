<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Yƒ±lan</title>
  <style>
    :root{
      --bg1:#040b1a;
      --bg2:#061435;
      --card:#0a1a3a;
      --card2:#081635;
      --stroke:rgba(255,255,255,.08);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --btn:rgba(255,255,255,.08);
      --btn2:rgba(255,255,255,.12);
      --accent:#2b8cff;
      --good:#33d17a;
      --food:#ff4d4d;
      --big:#ffcc00;
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --r:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      min-height:100vh;
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(43,140,255,.18), transparent 60%),
        radial-gradient(900px 500px at 80% 0%, rgba(255,77,77,.10), transparent 65%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    .topbar{
      position:sticky;
      top:0;
      z-index:5;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(3,10,26,.85), rgba(3,10,26,.55));
      border-bottom: 1px solid var(--stroke);
    }
    .topbar-inner{
      max-width: 1100px;
      margin: 0 auto;
      padding: 14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:800;
      letter-spacing:.2px;
    }
    .brand .icon{font-size:18px; opacity:.9}
    .brand .title{font-size:16px}
    .home{
      color:var(--text);
      text-decoration:none;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
    }
    .home:hover{background: rgba(255,255,255,.06)}

    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding: 18px 16px 28px;
    }

    .hero{
      text-align:center;
      padding: 14px 8px 10px;
    }
    .hero h1{
      margin:8px 0 6px;
      font-size: clamp(28px, 4vw, 44px);
      letter-spacing:.3px;
    }
    .stats{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:14px;
      color:var(--muted);
      font-weight:600;
    }
    .stat{
      padding:8px 12px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
    }

    /* GAME CARD LAYOUT */
    .card{
      margin-top: 14px;
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(10,26,58,.65), rgba(8,22,53,.65));
      box-shadow: var(--shadow);
      padding: 16px;
    }

    /* Desktop: 2 columns. Mobile: 1 column stacked */
    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 16px;
      align-items: stretch;
    }
    @media (max-width: 900px){
      .grid{grid-template-columns: 1fr;}
    }

    /* Canvas box keeps everything together (so controls don't fall down) */
    .canvas-box{
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      padding: 12px;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height: 320px;
    }

    /* Make canvas responsive but capped (desktop not too huge) */
    canvas{
      width: min(560px, 92vw);
      aspect-ratio: 1 / 1;
      height:auto;
      border-radius: 14px;
      background: rgba(0,0,0,.22);
      display:block;
      touch-action: none; /* important for swipe */
    }
    @media (max-width: 420px){
      canvas{ width: min(360px, 94vw); }
    }

    .panel{
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.12);
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-start;
    }

    .btn{
      border:1px solid var(--stroke);
      background: var(--btn);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:700;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:hover{background: var(--btn2)}
    .btn.primary{
      background: rgba(43,140,255,.18);
      border-color: rgba(43,140,255,.35);
    }
    .btn.danger{
      background: rgba(255,77,77,.14);
      border-color: rgba(255,77,77,.30);
    }

    .speed{
      display:flex;
      gap:10px;
      align-items:center;
      width:100%;
    }
    .speed label{color:var(--muted); font-weight:700}
    .speed input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .pill{
      min-width: 44px;
      text-align:center;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      font-weight:800;
    }

    .dpad{
      display:grid;
      grid-template-columns: 70px 70px 70px;
      grid-template-rows: 70px 70px 70px;
      gap: 10px;
      justify-content:center;
      align-content:center;
      padding-top: 6px;
    }
    @media (max-width: 420px){
      .dpad{
        grid-template-columns: 62px 62px 62px;
        grid-template-rows: 62px 62px 62px;
        gap: 8px;
      }
    }
    .dpad button{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 16px;
      font-size: 20px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .dpad button:active{transform: translateY(1px); background: rgba(255,255,255,.10)}
    .dpad .empty{visibility:hidden}

    .help{
      margin-top:auto;
      color:var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .footer{
      text-align:center;
      color: rgba(255,255,255,.55);
      margin-top: 14px;
      font-size: 13px;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <span class="icon">üêç</span>
        <span class="title">Yƒ±lan</span>
      </div>
      <a class="home" href="./index.html">‚Üê Ana Sayfa</a>
    </div>
  </div>

  <div class="wrap">
    <div class="hero">
      <h1>Yƒ±lan</h1>
      <div class="stats">
        <div class="stat">Skor: <span id="score">0</span></div>
        <div class="stat">Rekor: <span id="best">0</span></div>
        <div class="stat">Hƒ±z: <span id="speedLabel">8</span></div>
      </div>
    </div>

    <div class="card">
      <div class="grid">
        <div class="canvas-box">
          <canvas id="game" width="600" height="600" aria-label="Snake game"></canvas>
        </div>

        <div class="panel">
          <div class="row">
            <button class="btn primary" id="btnStart">Ba≈ülat</button>
            <button class="btn" id="btnPause">Duraklat</button>
            <button class="btn danger" id="btnReset">Yeniden</button>
          </div>

          <div class="speed">
            <label>Hƒ±z</label>
            <button class="btn" id="btnSlow">‚àí</button>
            <input id="speed" type="range" min="2" max="16" step="1" value="8" />
            <button class="btn" id="btnFast">+</button>
            <div class="pill" id="speedPill">8</div>
          </div>

          <div class="dpad" aria-label="Y√∂n tu≈ülarƒ±">
            <div class="empty"></div>
            <button data-dir="up">‚ñ≤</button>
            <div class="empty"></div>

            <button data-dir="left">‚óÄ</button>
            <div class="empty"></div>
            <button data-dir="right">‚ñ∂</button>

            <div class="empty"></div>
            <button data-dir="down">‚ñº</button>
            <div class="empty"></div>
          </div>

          <div class="help">
            <b>Masa√ºst√º:</b> Ok tu≈ülarƒ± veya WASD<br/>
            <b>Mobil:</b> Y√∂n tu≈ülarƒ± veya alanda kaydƒ±r (swipe)<br/>
            <b>ƒ∞pucu:</b> Hƒ±zƒ± slider veya +/‚àí ile deƒüi≈ütir<br/>
            <b>B√ºy√ºk lokma:</b> Sarƒ± yem kƒ±sa s√ºreli √ßƒ±kar, √ßok puan verir üòÑ
          </div>
        </div>
      </div>

      <div class="footer">¬© 2026 Mini Oyunlar</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const speedEl = document.getElementById('speed');
  const speedLabelEl = document.getElementById('speedLabel');
  const speedPillEl = document.getElementById('speedPill');

  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');
  const btnSlow = document.getElementById('btnSlow');
  const btnFast = document.getElementById('btnFast');

  // Grid settings
  const GRID = 22; // slightly denser than classic
  let cell = 20;   // computed from canvas size
  const pad = 1;   // gridline thickness effect

  // Game state
  let snake, dir, nextDirQueue, food, bigFood;
  let score = 0;
  let best = Number(localStorage.getItem('snake_best_tr') || '0');
  bestEl.textContent = best;

  // timing
  let running = false;
  let paused = false;
  let speed = 8; // 2..16
  let stepMs = speedToStepMs(speed);
  let acc = 0;
  let lastTs = 0;

  function speedToStepMs(s){
    // Higher speed => smaller step time.
    // 2 => ~220ms, 16 => ~70ms (feels snappy but controllable)
    return Math.round(260 - (s * 12));
  }

  function setSpeed(v){
    speed = Math.max(2, Math.min(16, v|0));
    stepMs = speedToStepMs(speed);
    speedEl.value = String(speed);
    speedLabelEl.textContent = speed;
    speedPillEl.textContent = speed;
  }

  function resetGame(){
    score = 0;
    scoreEl.textContent = score;

    // Start centered, going right
    const mid = Math.floor(GRID/2);
    snake = [
      {x: mid-1, y: mid},
      {x: mid,   y: mid},
      {x: mid+1, y: mid},
    ];
    dir = {x: 1, y: 0};
    nextDirQueue = [];

    food = spawnFood();
    bigFood = null;

    paused = false;
    updateButtons();
    draw();
  }

  function updateButtons(){
    // Start button should not tell "restart" nonsense.
    btnStart.textContent = running ? 'Devam' : 'Ba≈ülat';
    btnPause.textContent = paused ? 'Devam Et' : 'Duraklat';
  }

  function spawnFood(){
    while(true){
      const f = {
        x: randInt(0, GRID-1),
        y: randInt(0, GRID-1),
        value: 1,
        kind: 'normal'
      };
      if (!isOnSnake(f.x, f.y)) return f;
    }
  }

  function spawnBigFood(){
    // 2x2-ish feel but we keep it 1 cell for simplicity; render larger visually.
    // It gives extra score and extra growth.
    while(true){
      const f = {
        x: randInt(0, GRID-1),
        y: randInt(0, GRID-1),
        value: 5,
        grow: 3,
        kind: 'big',
        ttl: 3500 // ms
      };
      if (!isOnSnake(f.x, f.y) && !(food && food.x===f.x && food.y===f.y)) return f;
    }
  }

  function isOnSnake(x,y){
    return snake.some(p => p.x===x && p.y===y);
  }

  function randInt(a,b){ return (Math.random()*(b-a+1)+a)|0; }

  // ===== INPUT (fix for fast direction changes) =====
  // We queue direction changes and consume one per tick.
  // This prevents missing rapid key presses.
  function enqueueDir(nx, ny){
    // Prevent 180¬∞ reverse relative to "effective" last queued direction (or current dir)
    const last = nextDirQueue.length ? nextDirQueue[nextDirQueue.length-1] : dir;
    if (nx === -last.x && ny === -last.y) return; // reverse not allowed

    // Avoid duplicates
    if (nx === last.x && ny === last.y) return;

    // Keep queue small (snappy)
    if (nextDirQueue.length < 3){
      nextDirQueue.push({x:nx,y:ny});
    }else{
      // Replace the last one if user spams
      nextDirQueue[nextDirQueue.length-1] = {x:nx,y:ny};
    }
  }

  function handleKey(e){
    const k = e.key.toLowerCase();
    if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(k)){
      e.preventDefault();
    }
    if (k==='arrowup' || k==='w') enqueueDir(0,-1);
    else if (k==='arrowdown' || k==='s') enqueueDir(0, 1);
    else if (k==='arrowleft' || k==='a') enqueueDir(-1,0);
    else if (k==='arrowright' || k==='d') enqueueDir(1,0);
    else if (k===' '){
      // Space: pause/resume
      togglePause();
    }
  }
  window.addEventListener('keydown', handleKey, {passive:false});

  // On-screen dpad: use pointerdown (faster than click on mobile)
  document.querySelectorAll('.dpad button[data-dir]').forEach(btn=>{
    btn.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      const d = btn.getAttribute('data-dir');
      if (d==='up') enqueueDir(0,-1);
      if (d==='down') enqueueDir(0, 1);
      if (d==='left') enqueueDir(-1,0);
      if (d==='right') enqueueDir(1,0);
    }, {passive:false});
  });

  // Swipe on canvas
  let touchStart = null;
  canvas.addEventListener('pointerdown', (e)=>{
    // only for touch/pen; but safe for mouse too
    touchStart = {x:e.clientX, y:e.clientY, t:performance.now()};
  }, {passive:true});

  canvas.addEventListener('pointerup', (e)=>{
    if(!touchStart) return;
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    const adx = Math.abs(dx);
    const ady = Math.abs(dy);
    const dist = Math.hypot(dx,dy);
    touchStart = null;

    // require minimum swipe distance
    if (dist < 20) return;

    if (adx > ady){
      enqueueDir(dx>0 ? 1 : -1, 0);
    }else{
      enqueueDir(0, dy>0 ? 1 : -1);
    }
  }, {passive:true});

  // ===== Controls =====
  btnStart.addEventListener('click', ()=>{
    if (!running){
      running = true;
      paused = false;
      lastTs = 0;
      acc = 0;
      requestAnimationFrame(loop);
    }else{
      paused = false;
    }
    updateButtons();
  });

  function togglePause(){
    if (!running) return;
    paused = !paused;
    updateButtons();
  }

  btnPause.addEventListener('click', ()=>{
    if (!running){
      running = true;
      paused = true;
      lastTs = 0;
      acc = 0;
      requestAnimationFrame(loop);
    }else{
      togglePause();
    }
  });

  btnReset.addEventListener('click', ()=>{
    running = true;   // keep running after reset
    paused = false;
    resetGame();
    lastTs = 0;
    acc = 0;
    updateButtons();
    requestAnimationFrame(loop);
  });

  btnSlow.addEventListener('click', ()=> setSpeed(speed-1));
  btnFast.addEventListener('click', ()=> setSpeed(speed+1));
  speedEl.addEventListener('input', ()=> setSpeed(Number(speedEl.value)));

  // ===== Responsive canvas sizing =====
  function resizeCanvas(){
    // match CSS size but set internal resolution for crisp lines
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // internal size
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.width * dpr); // square

    // compute cell size in pixels (internal)
    cell = Math.floor(canvas.width / GRID);
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  // ===== Game tick =====
  function tick(dt){
    if (!running || paused) return;

    // Big food TTL
    if (bigFood){
      bigFood.ttl -= dt;
      if (bigFood.ttl <= 0) bigFood = null;
    }

    // apply queued direction (one per tick)
    if (nextDirQueue.length){
      dir = nextDirQueue.shift();
    }

    const head = snake[snake.length-1];
    const nx = head.x + dir.x;
    const ny = head.y + dir.y;

    // wall collision
    if (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID){
      gameOver();
      return;
    }

    // self collision (ignore tail if it moves away)
    const tail = snake[0];
    const hitsBody = snake.some((p, idx)=>{
      // allow moving into current tail position if not growing this tick
      if (p.x===nx && p.y===ny){
        return !(idx===0 && !(nx===food.x && ny===food.y) && !(bigFood && nx===bigFood.x && ny===bigFood.y));
      }
      return false;
    });
    if (hitsBody){
      gameOver();
      return;
    }

    // move
    snake.push({x:nx, y:ny});

    let ate = false;
    let growBy = 0;

    // eat normal
    if (nx===food.x && ny===food.y){
      ate = true;
      score += 1;
      growBy += 1;
      food = spawnFood();

      // chance to spawn big bite sometimes
      if (!bigFood && Math.random() < 0.22){ // ~1 in 5
        bigFood = spawnBigFood();
      }
    }

    // eat big
    if (bigFood && nx===bigFood.x && ny===bigFood.y){
      ate = true;
      score += bigFood.value;
      growBy += bigFood.grow;
      bigFood = null;
    }

    // update best
    if (score > best){
      best = score;
      localStorage.setItem('snake_best_tr', String(best));
      bestEl.textContent = best;
    }
    scoreEl.textContent = score;

    // trim tail unless growing
    const keep = snake.length - 1 - growBy;
    while (snake.length > keep){
      snake.shift();
    }

    draw();
  }

  function gameOver(){
    paused = true;
    updateButtons();
    // small visual feedback
    flash();
  }

  function flash(){
    let n = 0;
    const id = setInterval(()=>{
      n++;
      ctx.globalAlpha = (n%2) ? 0.4 : 1;
      draw();
      ctx.globalAlpha = 1;
      if (n>=6) clearInterval(id);
    }, 80);
  }

  // ===== Render =====
  function draw(){
    // background
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // soft bg
    ctx.fillStyle = 'rgba(0,0,0,.20)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // grid
    ctx.strokeStyle = 'rgba(255,255,255,.06)';
    ctx.lineWidth = Math.max(1, Math.floor(cell * 0.06));
    for(let i=0;i<=GRID;i++){
      const p = i*cell + 0.5;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,GRID*cell); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(GRID*cell,p); ctx.stroke();
    }

    // food
    drawCell(food.x, food.y, 'normal');

    // big food
    if (bigFood) drawCell(bigFood.x, bigFood.y, 'big');

    // snake
    for(let i=0;i<snake.length;i++){
      const p = snake[i];
      const isHead = (i===snake.length-1);
      const alpha = isHead ? 1 : 0.9;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = isHead ? 'rgba(51,209,122,0.98)' : 'rgba(51,209,122,0.82)';
      roundRect(p.x*cell + pad, p.y*cell + pad, cell - pad*2, cell - pad*2, Math.max(6, cell*0.22));
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // paused overlay
    if (!running){
      overlayText('Ba≈ülatmak i√ßin ‚ÄúBa≈ülat‚Äù');
    } else if (paused){
      overlayText('Duraklatƒ±ldƒ±');
    }
  }

  function drawCell(x,y,kind){
    if (kind==='normal'){
      ctx.fillStyle = 'rgba(255,77,77,0.95)';
      roundRect(x*cell + pad, y*cell + pad, cell - pad*2, cell - pad*2, Math.max(6, cell*0.22));
      ctx.fill();
    } else {
      // big bite: visually larger and glowing
      const cx = x*cell + cell/2;
      const cy = y*cell + cell/2;
      const r = cell*0.52;

      ctx.save();
      ctx.shadowColor = 'rgba(255,204,0,.45)';
      ctx.shadowBlur = Math.max(8, cell*0.6);
      ctx.fillStyle = 'rgba(255,204,0,0.95)';
      ctx.beginPath();
      ctx.roundRect(x*cell + pad, y*cell + pad, cell - pad*2, cell - pad*2, Math.max(8, cell*0.28));
      ctx.fill();
      ctx.restore();

      // tiny highlight
      ctx.fillStyle = 'rgba(255,255,255,.35)';
      ctx.beginPath();
      ctx.arc(cx - r*0.25, cy - r*0.25, r*0.18, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function overlayText(t){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = 'rgba(255,255,255,.92)';
    ctx.font = `700 ${Math.max(16, Math.floor(canvas.width*0.045))}px system-ui`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(t, canvas.width/2, canvas.height/2);
    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // ===== RAF LOOP =====
  function loop(ts){
    if (!running){
      draw();
      return;
    }
    if (!lastTs) lastTs = ts;
    const dt = ts - lastTs;
    lastTs = ts;

    // accumulate time and tick with fixed step
    acc += dt;
    // Avoid spiral of death on background tab
    const maxAcc = stepMs * 5;
    if (acc > maxAcc) acc = maxAcc;

    while (acc >= stepMs){
      tick(stepMs);
      acc -= stepMs;
      if (paused) break;
    }

    requestAnimationFrame(loop);
  }

  // init
  setSpeed(8);
  resetGame();
  resizeCanvas();

  // Start with running=false (overlay shows start text)
  running = false;
  paused = false;
  updateButtons();
})();
</script>
</body>
</html>
