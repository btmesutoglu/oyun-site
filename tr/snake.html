<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Yƒ±lan</title>
  <style>
    :root{
      --bg1:#040b1a;
      --bg2:#061435;
      --card:#0a1a3a;
      --card2:#081635;
      --stroke:rgba(255,255,255,.08);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --btn:rgba(255,255,255,.08);
      --btn2:rgba(255,255,255,.12);
      --accent:#2b8cff;
      --good:#33d17a;
      --food:#ff4d4d;
      --big:#ffcc00;
      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --r:18px;
    }
    *{box-sizing:border-box}

    html, body{
      height:100%;
      overflow:hidden;
    }
    body{
      position:fixed;
      inset:0;
      overscroll-behavior: none;
    }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      min-height:100vh;
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(43,140,255,.18), transparent 60%),
        radial-gradient(900px 500px at 80% 0%, rgba(255,77,77,.10), transparent 65%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    .topbar{
      position:sticky;
      top:0;
      z-index:5;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(3,10,26,.85), rgba(3,10,26,.55));
      border-bottom: 1px solid var(--stroke);
    }
    .topbar-inner{
      max-width: 1100px;
      margin: 0 auto;
      padding: 14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:800;
      letter-spacing:.2px;
    }
    .brand .icon{font-size:18px; opacity:.9}
    .brand .title{font-size:16px}
    .home{
      color:var(--text);
      text-decoration:none;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
    }
    .home:hover{background: rgba(255,255,255,.06)}

    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding: 18px 16px 18px;
      height: calc(100svh - 64px);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    .hero{
      text-align:center;
      padding: 14px 8px 10px;
    }
    .hero h1{
      margin:8px 0 6px;
      font-size: clamp(28px, 4vw, 44px);
      letter-spacing:.3px;
    }
    .stats{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:14px;
      color:var(--muted);
      font-weight:600;
    }
    .stat{
      padding:8px 12px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
    }

    .card{
      margin-top: 14px;
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(10,26,58,.65), rgba(8,22,53,.65));
      box-shadow: var(--shadow);
      padding: 16px;
      flex:1;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 360px;
      gap: 16px;
      align-items: stretch;
      flex:1;
      min-height:0;
      overflow:hidden;
    }
    @media (max-width: 900px){
      .grid{grid-template-columns: 1fr;}
    }

    .canvas-box{
      position: relative;
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      padding: 12px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex:1;
      min-height: 0;
    }

    canvas{
      width: min(520px, 70vmin);
      max-width: 520px;
      aspect-ratio: 1 / 1;
      height:auto;
      border-radius: 14px;
      background: rgba(0,0,0,.22);
      display:block;
      touch-action: none;
      outline: none;
    }
    @media (max-width: 420px){
      canvas{ width: min(360px, 94vw); }
    }

    .panel{
      border-radius: var(--r);
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.12);
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-start;
    }

    .btn{
      border:1px solid var(--stroke);
      background: var(--btn);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:700;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:hover{background: var(--btn2)}
    .btn.primary{
      background: rgba(43,140,255,.18);
      border-color: rgba(43,140,255,.35);
    }
    .btn.danger{
      background: rgba(255,77,77,.14);
      border-color: rgba(255,77,77,.30);
    }

    .btn.icon{
      width: 44px;
      height: 44px;
      padding: 0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius: 14px;
      font-size: 18px;
      font-weight: 900;
    }

    .btn.on{
      background: rgba(255,204,0,.16);
      border-color: rgba(255,204,0,.35);
    }

    .speed{
      display:flex;
      gap:10px;
      align-items:center;
      width:100%;
    }
    .speed label{color:var(--muted); font-weight:700}
    .speed input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .pill{
      min-width: 44px;
      text-align:center;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      font-weight:800;
    }

    /* Speed controls locked while playing (except auto) */
    .speed.locked{ opacity: .75; }
    .speed.locked input,
    .speed.locked button:not(#btnAuto){
      pointer-events: none;
    }
    .speed.locked input{ filter: grayscale(1); }

    .dpad{
      display:grid;
      grid-template-columns: 70px 70px 70px;
      grid-template-rows: 70px 70px 70px;
      gap: 10px;
      justify-content:center;
      align-content:center;
      padding-top: 6px;
    }
    @media (max-width: 420px){
      .dpad{
        grid-template-columns: 62px 62px 62px;
        grid-template-rows: 62px 62px 62px;
        gap: 8px;
      }
    }
    .dpad button{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 16px;
      font-size: 20px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .dpad button:active{transform: translateY(1px); background: rgba(255,255,255,.10)}
    .dpad .empty{visibility:hidden}

    .help{
      margin-top:auto;
      color:var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .footer{
      text-align:center;
      color: rgba(255,255,255,.55);
      margin-top: 14px;
      font-size: 13px;
    }

    /* Game-over restart overlay button */
    .overlay-restart{
      position:absolute;
      inset: 0;
      margin:auto;
      width: 78px;
      height: 78px;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.45);
      color: rgba(255,255,255,.95);
      font-size: 34px;
      font-weight: 900;
      display:none;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
    }
    .overlay-restart.show{ display:flex; }
    .overlay-restart:active{ transform: translateY(1px); }

    /* Mobile: snake odak, daha kompakt */
    @media (max-width: 900px){
      .hero{ padding: 8px 6px 6px; }
      .stats{ gap: 8px; }
      .stat{ padding: 6px 10px; }

      .wrap{ padding: 10px 12px 10px; height: calc(100svh - 58px); }

      .card{ padding: 10px; margin-top: 10px; }

      .grid{ grid-template-columns: 1fr; gap: 12px; }

      .canvas-box{ padding: 10px; }

      /* Paneli altta sabitle: mobilde kaydƒ±rma yok, tu≈ülar hep eri≈üilebilir */
      .panel{
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        bottom: max(10px, env(safe-area-inset-bottom));
        width: min(520px, calc(100vw - 20px));
        z-index: 20;
        background: rgba(0,0,0,.22);
        backdrop-filter: blur(10px);
        box-shadow: 0 18px 45px rgba(0,0,0,.45);
      }

      /* D-pad daha b√ºy√ºk ve parmak dostu */
      .dpad{
        --s: 76px;
        grid-template-columns: var(--s) var(--s) var(--s);
        grid-template-rows: var(--s) var(--s) var(--s);
        gap: 10px;
        padding-top: 2px;
      }
      .dpad button{
        font-size: 24px;
        border-radius: 18px;
      }

      .btn.icon{ width: 52px; height: 52px; border-radius: 16px; font-size: 20px; }
      .btn{ padding: 12px 16px; border-radius: 16px; }

      .help{ display:none; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <span class="icon">üêç</span>
        <span class="title">Yƒ±lan</span>
      </div>
      <a class="home" href="./index.html">‚Üê Ana Sayfa</a>
    </div>
  </div>

  <div class="wrap">
    <div class="hero">
      <h1>Yƒ±lan</h1>
      <div class="stats">
        <div class="stat">Skor: <span id="score">0</span></div>
        <div class="stat">Rekor: <span id="best">0</span></div>
        <div class="stat">Hƒ±z: <span id="speedLabel">8</span></div>
      </div>
    </div>

    <div class="card">
      <div class="grid">
        <div class="canvas-box">
          <canvas id="game" width="600" height="600" aria-label="Snake game" tabindex="0"></canvas>

          <button class="overlay-restart" id="overlayRestart" aria-label="Yeniden ba≈ülat" title="Yeniden ba≈ülat">‚Üª</button>
        </div>

        <div class="panel">
          <div class="row">
            <button class="btn primary icon" id="btnStart" aria-label="Ba≈ülat / Devam" title="Ba≈ülat / Devam">‚ñ∂</button>
            <button class="btn icon" id="btnPause" aria-label="Duraklat / Devam Et" title="Duraklat / Devam Et">‚è∏</button>
            <button class="btn danger icon" id="btnReset" aria-label="Yeniden ba≈ülat" title="Yeniden ba≈ülat">‚Üª</button>
          </div>

          <div class="speed">
            <label>Hƒ±z</label>

            <button class="btn icon on" id="btnAuto" aria-label="Otomatik hƒ±zlanma" title="Otomatik hƒ±zlanma">‚ö°</button>

            <button class="btn" id="btnSlow">‚àí</button>
            <input id="speed" type="range" min="2" max="16" step="1" value="8" />
            <button class="btn" id="btnFast">+</button>
            <div class="pill" id="speedPill">8</div>
          </div>

          <div class="dpad" aria-label="Y√∂n tu≈ülarƒ±">
            <div class="empty"></div>
            <button data-dir="up">‚ñ≤</button>
            <div class="empty"></div>

            <button data-dir="left">‚óÄ</button>
            <div class="empty"></div>
            <button data-dir="right">‚ñ∂</button>

            <div class="empty"></div>
            <button data-dir="down">‚ñº</button>
            <div class="empty"></div>
          </div>

          <div class="help">
            <b>Masa√ºst√º:</b> Ok tu≈ülarƒ± veya WASD<br/>
            <b>Mobil:</b> Y√∂n tu≈ülarƒ± veya alanda kaydƒ±r (swipe)<br/>
            <b>ƒ∞pucu:</b> Oyun bitince hƒ±z slider ile ayarlanƒ±r<br/>
            <b>Oto hƒ±z:</b> ‚ö° a√ßƒ±kken oyun zamanla hƒ±zlanƒ±r (daha yava≈ü hƒ±zlanƒ±r)<br/>
            <b>B√ºy√ºk lokma:</b> Sarƒ± lokma ara sƒ±ra √ßƒ±kar, yakalarsan +puan ve ekstra uzarsƒ±n üòÑ
          </div>
        </div>
      </div>

      <div class="footer">¬© 2026 Mini Oyunlar</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const speedEl = document.getElementById('speed');
  const speedLabelEl = document.getElementById('speedLabel');
  const speedPillEl = document.getElementById('speedPill');

  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');
  const btnSlow = document.getElementById('btnSlow');
  const btnFast = document.getElementById('btnFast');

  const btnAuto = document.getElementById('btnAuto');
  const speedRow = document.querySelector('.speed');

  const overlayRestart = document.getElementById('overlayRestart');

  // Grid settings
  const GRID = 22;
  let cell = 20;
  const pad = 1;

  // Game state
  let snake, dir, nextDirQueue, food, bigFood;
  let score = 0;
  let normalEaten = 0;
  let best = Number(localStorage.getItem('snake_best_tr') || '0');
  bestEl.textContent = best;

  // Grow system
  let growLeft = 0;

  // timing / loop
  let running = false;
  let paused = false;
  let rafId = null;
  let acc = 0;
  let lastTs = 0;

  // Speed system: base (user), current (effective)
  let baseSpeed = 8;       // user selected (2..16)
  let currentSpeed = 8;    // effective speed (auto-accel changes this)
  let autoAccel = true;    // default ON
  let accelTimer = 0;
  const accelEveryMs = 14000; // every 14s => +1 speed (up to 16)

  let stepMs = speedToStepMs(currentSpeed);

  let gameOverFlag = false;

  function speedToStepMs(s){
    // 2 => ~236ms, 16 => ~68ms
    return Math.round(260 - (s * 12));
  }

  function showRestartOverlay(show){
    overlayRestart.classList.toggle('show', !!show);
  }

  function canEditSpeed(){
    // before first start OR after game over, user can set base speed
    return (!running) || gameOverFlag;
  }

  function applyEffectiveSpeed(){
    stepMs = speedToStepMs(currentSpeed);
    speedLabelEl.textContent = currentSpeed;
    speedPillEl.textContent = currentSpeed;
  }

  function setBaseSpeed(v){
    baseSpeed = Math.max(2, Math.min(16, v|0));
    speedEl.value = String(baseSpeed);

    if (!running || gameOverFlag){
      currentSpeed = baseSpeed;
      applyEffectiveSpeed();
    }
  }

  function setSpeed(v){
    if (!canEditSpeed()){
      speedEl.value = String(baseSpeed);
      return;
    }
    setBaseSpeed(v);
    updateSpeedUI();
  }

  function updateSpeedUI(){
    btnAuto.classList.toggle('on', autoAccel);
    speedRow.classList.toggle('locked', running && !gameOverFlag);
  }

  function updateButtons(){
    // Start: always ‚ñ∂ ; Pause toggles ‚è∏ / ‚ñ∂
    btnStart.textContent = '‚ñ∂';
    btnPause.textContent = paused ? '‚ñ∂' : '‚è∏';
  }

  function requestLoop(){
    if (rafId === null){
      rafId = requestAnimationFrame(loop);
    }
  }

  function ensureRunning(){
    if (!running){
      running = true;
      paused = false;
      lastTs = 0;
      acc = 0;
      requestLoop();
    } else if (paused){
      paused = false;
    }
    updateButtons();
    updateSpeedUI();
    try { canvas.focus(); } catch(_) {}
  }

  function restartAndRun(){
    running = true;
    paused = false;
    resetGame();
    lastTs = 0;
    acc = 0;
    ensureRunning();
  }

  function resetGame(){
    score = 0;
    normalEaten = 0;
    scoreEl.textContent = score;

    const mid = Math.floor(GRID/2);
    snake = [
      {x: mid-1, y: mid},
      {x: mid,   y: mid},
      {x: mid+1, y: mid},
    ];
    dir = {x: 1, y: 0};
    nextDirQueue = [];
    growLeft = 0;

    food = spawnFood();
    bigFood = null;

    // reset speed progression for new run
    accelTimer = 0;
    currentSpeed = baseSpeed;
    applyEffectiveSpeed();

    gameOverFlag = false;
    showRestartOverlay(false);

    updateButtons();
    updateSpeedUI();
    draw();
  }

  function spawnFood(){
    while(true){
      const f = { x: randInt(0, GRID-1), y: randInt(0, GRID-1), kind:'normal' };
      if (!isOnSnake(f.x, f.y)) return f;
    }
  }

  function spawnBigFood(){
    while(true){
      const f = {
        x: randInt(0, GRID-1),
        y: randInt(0, GRID-1),
        value: 8,
        grow: 4,
        kind: 'big',
        ttl: 6000
      };
      if (!isOnSnake(f.x, f.y) && !(food && food.x===f.x && food.y===f.y)) return f;
    }
  }

  function isOnSnake(x,y){
    return snake.some(p => p.x===x && p.y===y);
  }
  function randInt(a,b){ return (Math.random()*(b-a+1)+a)|0; }

  // ===== INPUT (queue) =====
  function enqueueDir(nx, ny){
    // game over sonrasƒ± y√∂n tu≈üu ile de yeniden ba≈ülat (kullanƒ±cƒ± hissi iyi)
    if (gameOverFlag){
      restartAndRun();
    } else {
      ensureRunning();
    }

    const last = nextDirQueue.length ? nextDirQueue[nextDirQueue.length-1] : dir;
    if (nx === -last.x && ny === -last.y) return;
    if (nx === last.x && ny === last.y) return;

    if (nextDirQueue.length >= 6) nextDirQueue.shift();
    nextDirQueue.push({x:nx,y:ny});
  }

  function handleKey(e){
    if (e.repeat) return;

    const k = e.key.toLowerCase();
    if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d',' '].includes(k)){
      e.preventDefault();
    }

    if (k==='arrowup' || k==='w') enqueueDir(0,-1);
    else if (k==='arrowdown' || k==='s') enqueueDir(0, 1);
    else if (k==='arrowleft' || k==='a') enqueueDir(-1,0);
    else if (k==='arrowright' || k==='d') enqueueDir(1,0);
    else if (k===' '){
      togglePause();
    }
  }
  window.addEventListener('keydown', handleKey, {passive:false});

  // On-screen dpad
  document.querySelectorAll('.dpad button[data-dir]').forEach(btn=>{
    btn.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      const d = btn.getAttribute('data-dir');
      if (d==='up') enqueueDir(0,-1);
      if (d==='down') enqueueDir(0, 1);
      if (d==='left') enqueueDir(-1,0);
      if (d==='right') enqueueDir(1,0);
    }, {passive:false});
  });

  // Swipe on canvas (yalnƒ±zca oyun alanƒ±nda)
  let swipe = null;
  const SWIPE_MIN = 22;

  canvas.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    try{ canvas.setPointerCapture(e.pointerId); }catch(_){}
    swipe = {x:e.clientX, y:e.clientY, done:false};
  }, {passive:false});

  canvas.addEventListener('pointermove', (e)=>{
    if (!swipe || swipe.done) return;
    e.preventDefault();
    const dx = e.clientX - swipe.x;
    const dy = e.clientY - swipe.y;
    if (Math.hypot(dx,dy) < SWIPE_MIN) return;

    swipe.done = true;
    if (Math.abs(dx) > Math.abs(dy)){
      enqueueDir(dx>0 ? 1 : -1, 0);
    }else{
      enqueueDir(0, dy>0 ? 1 : -1);
    }
  }, {passive:false});

  function endSwipe(e){
    if (!swipe) return;
    e.preventDefault();
    swipe = null;
  }
  canvas.addEventListener('pointerup', endSwipe, {passive:false});
  canvas.addEventListener('pointercancel', endSwipe, {passive:false});

  // ===== Controls =====
  btnStart.addEventListener('click', ()=>{
    if (gameOverFlag){
      restartAndRun();
      return;
    }
    ensureRunning();
  });

  function togglePause(){
    if (!running) return;
    paused = !paused;
    updateButtons();
  }

  btnPause.addEventListener('click', ()=>{
    if (!running){
      running = true;
      paused = true;
      lastTs = 0;
      acc = 0;
      requestLoop();
    }else{
      togglePause();
    }
    updateButtons();
    updateSpeedUI();
  });

  btnReset.addEventListener('click', ()=>{
    restartAndRun();
  });

  btnSlow.addEventListener('click', ()=> setSpeed(baseSpeed-1));
  btnFast.addEventListener('click', ()=> setSpeed(baseSpeed+1));
  speedEl.addEventListener('input', ()=> setSpeed(Number(speedEl.value)));

  btnAuto.addEventListener('click', ()=>{
    autoAccel = !autoAccel;
    if (!autoAccel){
      accelTimer = 0;
      // Auto kapanƒ±nca efektif hƒ±z base'e d√∂ns√ºn (daha anla≈üƒ±lƒ±r)
      currentSpeed = baseSpeed;
      applyEffectiveSpeed();
    } else {
      // Auto a√ßƒ±lƒ±nca; oyun oynanƒ±yorsa timer sƒ±fƒ±rlayalƒ±m
      accelTimer = 0;
      if (!running || gameOverFlag){
        currentSpeed = baseSpeed;
        applyEffectiveSpeed();
      }
    }
    updateSpeedUI();
  });

  overlayRestart.addEventListener('click', ()=>{
    restartAndRun();
  });

  // ===== Responsive canvas sizing =====
  function resizeCanvas(){
    // Mobilde: panel altta sabit olduƒüu i√ßin canvas geni≈üliƒüini
    // hem ekrana hem de kalan y√ºksekliƒüe g√∂re ayarla (scroll olmasƒ±n).
    const mobile = window.matchMedia('(max-width: 900px)').matches;

    const topbarH = document.querySelector('.topbar')?.getBoundingClientRect().height || 0;
    const panelH = mobile ? (document.querySelector('.panel')?.getBoundingClientRect().height || 0) : 0;

    const sidePad = mobile ? 20 : 0;
    const verticalPad = mobile ? 18 : 0;

    const availH = Math.max(240, window.innerHeight - topbarH - panelH - verticalPad);
    const availW = Math.max(240, window.innerWidth - sidePad);

    // hedef: kare canvas
    const targetCss = mobile
      ? Math.floor(Math.min(availW, availH))
      : Math.floor(Math.min(520, availW, window.innerHeight*0.78));

    canvas.style.width = targetCss + 'px';

    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.width * dpr);

    cell = Math.floor(canvas.width / GRID);
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  // ===== Game tick =====
  function tick(dt){
    if (!running || paused) return;

    // Auto acceleration
    if (autoAccel && !gameOverFlag){
      accelTimer += dt;
      while (accelTimer >= accelEveryMs && currentSpeed < 16){
        accelTimer -= accelEveryMs;
        currentSpeed += 1;
        applyEffectiveSpeed();
      }
    }

    // Big food TTL
    if (bigFood){
      bigFood.ttl -= dt;
      if (bigFood.ttl <= 0) bigFood = null;
    }

    // apply queued direction (at most 1 meaningful turn per tick)
    while (nextDirQueue.length){
      const cand = nextDirQueue.shift();
      if (!(cand.x === -dir.x && cand.y === -dir.y)){
        dir = cand;
        break;
      }
    }

    const head = snake[snake.length-1];
    const nx = head.x + dir.x;
    const ny = head.y + dir.y;

    // wall collision
    if (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID){
      gameOver();
      return;
    }

    const willEatNormal = (nx===food.x && ny===food.y);
    const willEatBig = (bigFood && nx===bigFood.x && ny===bigFood.y);
    const willGrowThisTick = willEatNormal || willEatBig || (growLeft > 0);

    // collision: allow moving into tail only if tail will move away this tick
    const tailWillMove = !(willEatNormal || willEatBig || (growLeft > 0));
    let hits = false;
    for (let i=0;i<snake.length;i++){
      const p = snake[i];
      if (p.x===nx && p.y===ny){
        if (i===0 && tailWillMove){
          // OK: moving into current tail position while tail shifts away
        } else {
          hits = true;
        }
        break;
      }
    }
    if (hits){
      gameOver();
      return;
    }

    // move head
    snake.push({x:nx, y:ny});

    // eat / scoring
    if (willEatNormal){
      score += 1;
      growLeft += 1;
      food = spawnFood();

      normalEaten += 1;

      // Nokia tarzƒ±: her 7 normal lokmada bir b√ºy√ºk lokma √ßƒ±kabilir
      if (!bigFood && (normalEaten % 7 === 0)){
        bigFood = spawnBigFood();
      }
    }

    if (willEatBig){
      score += bigFood.value;
      growLeft += bigFood.grow;
      bigFood = null;
    }

    // tail handling
    if (growLeft > 0){
      growLeft -= 1;
    } else {
      snake.shift();
    }

    // update best / UI
    if (score > best){
      best = score;
      localStorage.setItem('snake_best_tr', String(best));
      bestEl.textContent = best;
    }
    scoreEl.textContent = score;

    draw();
  }

  function gameOver(){
    paused = true;
    gameOverFlag = true;
    showRestartOverlay(true);
    updateButtons();
    updateSpeedUI();
    flash();
  }

  function flash(){
    let n = 0;
    const id = setInterval(()=>{
      n++;
      ctx.globalAlpha = (n%2) ? 0.4 : 1;
      draw();
      ctx.globalAlpha = 1;
      if (n>=6) clearInterval(id);
    }, 80);
  }

  // ===== Render =====
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = 'rgba(0,0,0,.20)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // grid
    ctx.strokeStyle = 'rgba(255,255,255,.06)';
    ctx.lineWidth = Math.max(1, Math.floor(cell * 0.06));
    for(let i=0;i<=GRID;i++){
      const p = i*cell + 0.5;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,GRID*cell); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(GRID*cell,p); ctx.stroke();
    }

    // food
    drawCell(food.x, food.y, 'normal');

    // big food
    if (bigFood) drawCell(bigFood.x, bigFood.y, 'big');

    // snake
    for(let i=0;i<snake.length;i++){
      const p = snake[i];
      const isHead = (i===snake.length-1);
      const alpha = isHead ? 1 : 0.9;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = isHead ? 'rgba(51,209,122,0.98)' : 'rgba(51,209,122,0.82)';
      roundRect(p.x*cell + pad, p.y*cell + pad, cell - pad*2, cell - pad*2, Math.max(6, cell*0.22));
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // overlays
    if (!running){
      overlayText('Bir y√∂n tu≈üuna bas ‚Ä¢ veya ‚ñ∂');
    } else if (paused && !gameOverFlag){
      overlayText('Duraklatƒ±ldƒ±');
    } else if (paused && gameOverFlag){
      overlayText('Bitti! ‚Üª ile yeniden');
    }
  }

  function drawCell(x,y,kind){
    if (kind==='normal'){
      ctx.fillStyle = 'rgba(255,77,77,0.95)';
      roundRect(x*cell + pad, y*cell + pad, cell - pad*2, cell - pad*2, Math.max(6, cell*0.22));
      ctx.fill();
    } else {
      // big bite: glowing
      const cx = x*cell + cell/2;
      const cy = y*cell + cell/2;
      const r = cell*0.52;

      ctx.save();
      ctx.shadowColor = 'rgba(255,204,0,.45)';
      ctx.shadowBlur = Math.max(8, cell*0.6);
      ctx.fillStyle = 'rgba(255,204,0,0.95)';
      roundRect(x*cell + pad, y*cell + pad, cell - pad*2, cell - pad*2, Math.max(8, cell*0.28));
      ctx.fill();
      ctx.restore();

      ctx.fillStyle = 'rgba(255,255,255,.35)';
      ctx.beginPath();
      ctx.arc(cx - r*0.25, cy - r*0.25, r*0.18, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function overlayText(t){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = 'rgba(255,255,255,.92)';
    ctx.font = `700 ${Math.max(16, Math.floor(canvas.width*0.045))}px system-ui`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(t, canvas.width/2, canvas.height/2);
    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // ===== RAF LOOP =====
  function loop(ts){
    rafId = null;

    if (!running){
      draw();
      return;
    }

    if (!lastTs) lastTs = ts;
    const dt = ts - lastTs;
    lastTs = ts;

    acc += dt;
    const maxAcc = stepMs * 5;
    if (acc > maxAcc) acc = maxAcc;

    while (acc >= stepMs){
      tick(stepMs);
      acc -= stepMs;
      if (paused) break;
    }

    requestLoop();
  }

  // init
  setBaseSpeed(8);
  resetGame();
  resizeCanvas();

  // start in idle (overlay text visible)
  running = false;
  paused = false;
  gameOverFlag = false;
  showRestartOverlay(false);
  updateButtons();
  updateSpeedUI();
  draw();
})();
</script>
</body>
</html>
